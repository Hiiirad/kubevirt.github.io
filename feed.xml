<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://kubevirt.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://kubevirt.io//" rel="alternate" type="text/html" /><updated>2022-01-27T19:37:19+00:00</updated><id>https://kubevirt.io//feed.xml</id><title type="html">KubeVirt.io</title><subtitle>Virtual Machine Management on Kubernetes</subtitle><entry><title type="html">KubeVirt Summit is coming back!</title><link href="https://kubevirt.io//2022/KubeVirt-Summit-2022.html" rel="alternate" type="text/html" title="KubeVirt Summit is coming back!" /><published>2022-01-24T00:00:00+00:00</published><updated>2022-01-24T00:00:00+00:00</updated><id>https://kubevirt.io//2022/KubeVirt-Summit-2022</id><content type="html" xml:base="https://kubevirt.io//2022/KubeVirt-Summit-2022.html"><![CDATA[<p>The second online <a href="/summit/">KubeVirt Summit</a> is coming on February 16, 2022!</p>

<h2 id="when">When</h2>

<p>The event will take place online during two half-days:</p>

<ul>
  <li>Dates: February 16 and 17, 2022.</li>
  <li>Time: 14:00 ‚Äì 19:00 UTC (9:00‚Äì14:00 EST, 15:00‚Äì20:00 CET)</li>
</ul>

<h2 id="register">Register</h2>

<p><a href="/summit/">KubeVirt Summit</a> is hosted on Community.CNCF.io. Because of how that platform works, you need to register for each of the two days of the summit independantly:</p>

<ul>
  <li><a href="https://community.cncf.io/events/details/cncf-kubevirt-community-presents-kubevirt-summit-2022-day-1/">Register for Day 1</a></li>
  <li><a href="https://community.cncf.io/events/details/cncf-kubevirt-community-presents-kubevirt-summit-2022-day-2/">Register for Day 2</a></li>
</ul>

<p>You will need to create an account with CNCF.io if you have not before. Attendance is free.</p>

<h2 id="keep-up-to-date">Keep up to date</h2>

<p>Connect with the KubeVirt Community through our <a href="/community">community page</a>.</p>

<p>We are looking forward to meeting you there!</p>]]></content><author><name>Chandler Wilkerson</name></author><category term="news" /><category term="kubevirt" /><category term="event" /><category term="community" /><summary type="html"><![CDATA[Join us for the KubeVirt community's second annual dedicated online event]]></summary></entry><entry><title type="html">KubeVirt v0.49.0</title><link href="https://kubevirt.io//2022/changelog-v0.49.0.html" rel="alternate" type="text/html" title="KubeVirt v0.49.0" /><published>2022-01-11T00:00:00+00:00</published><updated>2022-01-11T00:00:00+00:00</updated><id>https://kubevirt.io//2022/changelog-v0.49.0</id><content type="html" xml:base="https://kubevirt.io//2022/changelog-v0.49.0.html"><![CDATA[<h2 id="v0490">v0.49.0</h2>

<p>Released on: Tue Jan 11 17:27:09 2022 +0000</p>

<ul>
  <li>[PR #7004][iholder-redhat] Bugfix: Avoid setting block migration for volumes used by read-only disks</li>
  <li>[PR #6959][enp0s3] generate event when target pod enters unschedulable phase</li>
  <li>[PR #6888][assafad] Added common labels into alert definitions</li>
  <li>[PR #6166][vasiliy-ul] Experimental support of AMD SEV</li>
  <li>[PR #6980][vasiliy-ul] Updated the dependencies to include the fix for CVE-2021-43565 (KubeVirt is not affected)</li>
  <li>[PR #6944][iholder-redhat] Remove disabling TLS configuration from Live Migration Policies</li>
  <li>[PR #6800][jean-edouard] CPU pinning doesn‚Äôt require hardware-assisted virtualization anymore</li>
  <li>[PR #6501][ShellyKa13] Use virtctl image-upload to upload archive content</li>
  <li>[PR #6918][iholder-redhat] Bug fix: Unscheduable host-model VMI alert is now properly triggered</li>
  <li>[PR #6796][Barakmor1] ‚Äòkubevirt-operator‚Äô changed to ‚Äòvirt-operator‚Äô on ‚Äòmanaged-by‚Äô label in kubevirt‚Äôs components made by virt-operator</li>
  <li>[PR #6036][jean-edouard] Migrations can now be done over a dedicated multus network</li>
  <li>[PR #6933][erkanerol] Add a new lane for monitoring tests</li>
  <li>[PR #6949][jean-edouard] KubeVirt components should now be successfully removed on CR deletion, even when using only 1 replica for virt-api and virt-controller</li>
  <li>[PR #6954][maiqueb] Update the <code class="language-plaintext highlighter-rouge">virtctl</code> exposed services <code class="language-plaintext highlighter-rouge">IPFamilyPolicyType</code> default to <code class="language-plaintext highlighter-rouge">IPFamilyPolicyPreferDualStack</code></li>
  <li>[PR #6931][fossedihelm] added DryRun to AddVolumeOptions and RemoveVolumeOptions</li>
  <li>[PR #6379][nunnatsa] Fix issue https://bugzilla.redhat.com/show_bug.cgi?id=1945593</li>
  <li>[PR #6399][iholder-redhat] Introduce live migration policies that allow system-admins to have fine-grained control over migration configuration for different sets of VMs.</li>
  <li>[PR #6880][iholder-redhat] Add full Podman support for <code class="language-plaintext highlighter-rouge">make</code> and <code class="language-plaintext highlighter-rouge">make test</code></li>
  <li>[PR #6702][acardace] implement virt-handler canary upgrade and rollback for faster and safer rollouts</li>
  <li>[PR #6717][davidvossel] Introducing the VirtualMachinePools feature for managing stateful VMs at scale</li>
  <li>[PR #6698][rthallisey] Add tracing to the virt-controller work queue</li>
  <li>[PR #6762][fossedihelm] added DryRun mode to virtcl to migrate command</li>
  <li>[PR #6891][rmohr] Fix ‚ÄúMake raw terminal failed: The handle is invalid?‚Äù issue with ‚Äúvirtctl console‚Äù when not executed in a pty</li>
  <li>[PR #6783][rmohr] Skip SSH RSA auth if no RSA key was explicitly provided and not key exists at the default location</li>
</ul>]]></content><author><name>kubeü§ñ</name></author><category term="releases" /><category term="release notes" /><category term="changelog" /><summary type="html"><![CDATA[This article provides information about KubeVirt release v0.49.0 changes]]></summary></entry><entry><title type="html">KubeVirt v0.48.0</title><link href="https://kubevirt.io//2021/changelog-v0.48.0.html" rel="alternate" type="text/html" title="KubeVirt v0.48.0" /><published>2021-12-06T00:00:00+00:00</published><updated>2021-12-06T00:00:00+00:00</updated><id>https://kubevirt.io//2021/changelog-v0.48.0</id><content type="html" xml:base="https://kubevirt.io//2021/changelog-v0.48.0.html"><![CDATA[<h2 id="v0480">v0.48.0</h2>

<p>Released on: Mon Dec 6 18:26:51 2021 +0000</p>

<ul>
  <li>[PR #6670][futuretea] Added ‚Äòvirtctl soft-reboot‚Äô command to reboot the VMI.</li>
  <li>[PR #6861][orelmisan] virtctl errors are written to stderr instead of stdout</li>
  <li>[PR #6836][enp0s3] Added PHASE and VMI columns for the ‚Äòkubectl get vmim‚Äô CLI output</li>
  <li>[PR #6784][nunnatsa] kubevirt-config configMap is no longer supported for KubeVirt configuration</li>
  <li>[PR #6839][ShellyKa13] fix restore of VM with RunStrategy</li>
  <li>[PR #6533][zcahana] Paused VMIs are now marked as unready even when no readinessProbe is specified</li>
  <li>[PR #6858][rmohr] Fix a nil pointer in virtctl in combination with some external auth plugins</li>
  <li>[PR #6780][fossedihelm] Add PatchOptions to the Patch request of the VirtualMachineInstanceInterface</li>
  <li>[PR #6773][iholder-redhat] alert if migration for VMI with host-model CPU is stuck since no node is suitable</li>
  <li>[PR #6714][rhrazdil] Shorten timeout for Istio proxy detection</li>
  <li>[PR #6725][fossedihelm] added DryRun mode to virtcl for pause and unpause commands</li>
  <li>[PR #6737][davidvossel] Pending migration target pods timeout after 5 minutes when unschedulable</li>
  <li>[PR #6814][fossedihelm] Changed some terminology to be more inclusive</li>
  <li>[PR #6649][Barakmor1] Designate the apps.kubevirt.io/component label for KubeVirt components.</li>
  <li>[PR #6650][victortoso] Introduces support to ich9 or ac97 sound devices</li>
  <li>[PR #6734][Barakmor1] replacing the command that extract libvirtd‚Äôs pid  to avoid this error:</li>
  <li>[PR #6802][rmohr] Maintain a separate api package which synchronizes to kubevirt.io/api for better third party integration with client-gen</li>
  <li>[PR #6730][zhhray] change kubevrit cert secret type from Opaque to kubernetes.io/tls</li>
  <li>[PR #6508][oshoval] Add missing domain to guest search list, in case subdomain is used.</li>
  <li>[PR #6664][vladikr] enable the display and ramfb for vGPUs by default</li>
  <li>[PR #6710][iholder-redhat] virt-launcher fix - stop logging successful shutdown when it isn‚Äôt true</li>
  <li>[PR #6162][vladikr] KVM_HINTS_REALTIME will always be set when dedicatedCpusPlacement is requested</li>
  <li>[PR #6772][zcahana] Bugfix: revert #6565 which prevented upgrades to v0.47.</li>
  <li>[PR #6722][zcahana] Remove obsolete scheduler.alpha.kubernetes.io/critical-pod annotation</li>
  <li>[PR #6723][acardace] remove stale pdbs created by &lt; 0.41.1 virt-controller</li>
  <li>[PR #6721][iholder-redhat] Set default CPU model in VMI spec, even if not defined in KubevirtCR</li>
  <li>[PR #6713][zcahana] Report WaitingForVolumeBinding VM status when PVC/DV-type volumes reference unbound PVCs</li>
  <li>[PR #6681][fossedihelm] Users can use ‚Äìdry-run flag</li>
  <li>[PR #6663][jean-edouard] The number of virt-api and virt-controller replicas is now configurable in the CSV</li>
  <li>[PR #5981][maya-r] Always resize disk.img files to the largest size at boot.</li>
</ul>]]></content><author><name>kubeü§ñ</name></author><category term="releases" /><category term="release notes" /><category term="changelog" /><summary type="html"><![CDATA[This article provides information about KubeVirt release v0.48.0 changes]]></summary></entry><entry><title type="html">Running real-time workloads with improved performance</title><link href="https://kubevirt.io//2021/Running-Realtime-Workloads.html" rel="alternate" type="text/html" title="Running real-time workloads with improved performance" /><published>2021-10-13T00:00:00+00:00</published><updated>2021-10-13T00:00:00+00:00</updated><id>https://kubevirt.io//2021/Running-Realtime-Workloads</id><content type="html" xml:base="https://kubevirt.io//2021/Running-Realtime-Workloads.html"><![CDATA[<h2 id="motivation">Motivation</h2>

<p>It has been possible in KubeVirt for some time already to run a VM running with a RT kernel, however the performance of such workloads never achieved parity against running on top of a bare metal host virtualized. With the availability of NUMA and CPUManager as features in KubeVirt, we were close to a point where we had almost all the ingredients to deliver the <a href="https://www.libvirt.org/kbase/kvm-realtime.html">recommended</a> tunings in libvirt for achieving the low CPU latency needed for such workloads. We were missing two important settings:</p>
<ul>
  <li>The ability to configure the VCPUs to run with real-time scheduling policy.</li>
  <li>Lock the VMs huge pages in RAM to prevent swapping.</li>
</ul>

<h2 id="setting-up-the-environment">Setting up the Environment</h2>
<p>To achieve the lowest latency possible in a given environment, first it needs to be configured to allow its resources to be consumed efficiently.</p>

<h3 id="the-cluster">The Cluster</h3>
<p>The target node has to be configured to reserve memory for hugepages and the kernel to allow threads to run with real-time scheduling policy. The memory can be reserved as a <a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/hugetlbpage.html">kernel boot parameter</a> or by changing the kernel‚Äôs page count at <a href="https://www.kernel.org/doc/html/latest/admin-guide/mm/hugetlbpage.html">runtime</a>.</p>

<p>The kernel‚Äôs runtime scheduling limit can be adjusted either by installing a real-time kernel in the node (the recommended option), or changing the kernel‚Äôs setting <code class="language-plaintext highlighter-rouge">kernel.sched_rt_runtime_us</code> to equal -1, to allow for unlimited runtime of real-time scheduled threads. This kernel setting defines the time period to be devoted to running real-time threads. KubeVirt will detect if the node has been configured with unlimited runtime and will label the node with <code class="language-plaintext highlighter-rouge">kubevirt.io/realtime</code> to highlight the capacity of running real-time workloads. Later on we‚Äôll come back to this label when we talk about how the workload is scheduled.</p>

<p>It is also recommended tuning the node‚Äôs BIOS settings for optimal real-time performance is also recommended to achieve even lower CPU latencies. Consult with your hardware provider to obtain the information on how to best tune your equipment.</p>

<h3 id="kubevirt">KubeVirt</h3>
<p>The VM will require to be granted fully dedicated CPUs and be able to use huge pages. These requirements can be achieved in KubeVirt by enabling the feature gates of CPUManager and NUMA in the KubeVirt CR. There is no dedicated feature gate to enable the new real-time optimizations.</p>

<h2 id="the-manifest">The Manifest</h2>
<p>With the cluster configured to provide the dedicated resources for the workload, it‚Äôs time to review an example of a VM manifest using the optimizations for low CPU latency. The first focus is to reduce the VM‚Äôs I/O by limiting it‚Äôs devices to only serial console:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.devices.autoattachSerialConsole</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">spec.domain.devices.autoattachMemBalloon</span><span class="pi">:</span> <span class="no">false</span>
<span class="na">spec.domain.devices.autoattachGraphicsDevice</span><span class="pi">:</span> <span class="no">false</span>
</code></pre></div></div>

<p>The pod needs to have a guaranteed QoS for its memory and CPU resources, to make sure that the CPU manager will dedicate the requested CPUs to the pod.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.resources.request.cpu</span><span class="pi">:</span> <span class="m">2</span>
<span class="na">spec.domain.resources.request.memory</span><span class="pi">:</span> <span class="s">1Gi</span>
<span class="na">spec.domain.resources.limits.cpu</span><span class="pi">:</span> <span class="m">2</span>
<span class="na">spec.domain.resources.limits.memory</span><span class="pi">:</span> <span class="s">1Gi</span>
</code></pre></div></div>

<p>Still on the CPU front, we add the settings to instruct the KVM to give a clear visibility of the host‚Äôs features to the guest, request the CPU manager in the node to isolate the assigned CPUs and to make sure that the emulator and IO threads in the VM run in their own dedicated VCPU rather than sharing the computational time with the workload.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.cpu.model</span><span class="pi">:</span> <span class="s">host-passthrough</span>
<span class="na">spec.domain.cpu.dedicateCpuPlacement</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">spec.domain.cpu.isolateEmulatorThread</span><span class="pi">:</span> <span class="no">true</span>
<span class="na">spec.domain.cpu.ioThreadsPolicy</span><span class="pi">:</span> <span class="s">auto</span>
</code></pre></div></div>

<p>We also request the huge pages size and guaranteed NUMA topology that will pin the CPU and memory resources to a single NUMA node in the host. The Kubernetes scheduler will perform due diligence to schedule the pod in a node with enough free huge pages of the given size.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.cpu.numa.guestMappingPassthrough</span><span class="pi">:</span> <span class="pi">{}</span>
<span class="na">spec.domain.memory.hugepages.pageSize</span><span class="pi">:</span> <span class="s">1Gi</span>
</code></pre></div></div>

<p>Lastly, we define the new real-time settings to instruct KubeVirt to apply the real-time scheduling policy for the pinned VCPUs and lock the process memory to avoid from being swapped by the host. In this example, we‚Äôll configure the workload to only apply the real-time scheduling policy to VCPU 0.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.cpu.realtime.mask</span><span class="pi">:</span> <span class="m">0</span>
</code></pre></div></div>

<p>Alternatively, if no <code class="language-plaintext highlighter-rouge">mask</code> value is specified, all requested CPUs will be configured for real-time scheduling.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec.domain.cpu.realtime</span><span class="pi">:</span> <span class="pi">{}</span>
</code></pre></div></div>

<p>The following yaml is a complete manifest including all the settings we just reviewed.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubevirt.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualMachine</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">kubevirt.io/vm</span><span class="pi">:</span> <span class="s">fedora-realtime</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">fedora-realtime</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">poc</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">running</span><span class="pi">:</span> <span class="no">true</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">kubevirt.io/vm</span><span class="pi">:</span> <span class="s">fedora-realtime</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">domain</span><span class="pi">:</span>
        <span class="na">devices</span><span class="pi">:</span>
          <span class="na">autoattachSerialConsole</span><span class="pi">:</span> <span class="no">true</span>
          <span class="na">autoattachMemBalloon</span><span class="pi">:</span> <span class="no">false</span>
          <span class="na">autoattachGraphicsDevice</span><span class="pi">:</span> <span class="no">false</span>
          <span class="na">disks</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">disk</span><span class="pi">:</span>
              <span class="na">bus</span><span class="pi">:</span> <span class="s">virtio</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">containerdisk</span>      
          <span class="pi">-</span> <span class="na">disk</span><span class="pi">:</span>
              <span class="na">bus</span><span class="pi">:</span> <span class="s">virtio</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">cloudinitdisk</span>
        <span class="na">machine</span><span class="pi">:</span>
          <span class="na">type</span><span class="pi">:</span> <span class="s2">"</span><span class="s">"</span>
        <span class="na">resources</span><span class="pi">:</span>
          <span class="na">requests</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s">1Gi</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="m">2</span>
          <span class="na">limits</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s">1Gi</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="m">2</span>
        <span class="na">cpu</span><span class="pi">:</span>
          <span class="na">model</span><span class="pi">:</span> <span class="s">host-passthrough</span>
          <span class="na">dedicatedCpuPlacement</span><span class="pi">:</span> <span class="no">true</span>
          <span class="na">isolateEmulatorThread</span><span class="pi">:</span> <span class="no">true</span>
          <span class="na">ioThreadsPolicy</span><span class="pi">:</span> <span class="s">auto</span>
          <span class="na">features</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">tsc-deadline</span>
              <span class="na">policy</span><span class="pi">:</span> <span class="s">require</span>
          <span class="na">numa</span><span class="pi">:</span>
            <span class="na">guestMappingPassthrough</span><span class="pi">:</span> <span class="pi">{}</span>
          <span class="na">realtime</span><span class="pi">:</span>
            <span class="na">mask</span><span class="pi">:</span> <span class="s2">"</span><span class="s">0"</span>
        <span class="na">memory</span><span class="pi">:</span>
          <span class="na">hugepages</span><span class="pi">:</span>
            <span class="na">pageSize</span><span class="pi">:</span> <span class="s">1Gi</span>
      <span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">0</span>
      <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">containerDisk</span><span class="pi">:</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">quay.io/kubevirt/fedora-realtime-container-disk:20211008_5a22acb18</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">containerdisk</span>
      <span class="pi">-</span> <span class="na">cloudInitNoCloud</span><span class="pi">:</span>
          <span class="na">userData</span><span class="pi">:</span> <span class="pi">|-</span>
            <span class="s">#cloud-config</span>
            <span class="s">password: fedora</span>
            <span class="s">chpasswd: { expire: False }</span>
            <span class="s">bootcmd:</span>
              <span class="s">- tuned-adm profile realtime</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">cloudinitdisk</span>
</code></pre></div></div>

<h2 id="the-deployment">The Deployment</h2>
<p>Because the manifest has enabled the real-time setting, when deployed KubeVirt applies the node label selector so that the Kubernetes scheduler will place the deployment in a node that is able to run threads with real-time scheduling policy (node label <code class="language-plaintext highlighter-rouge">kubevirt.io/realtime</code>). But there‚Äôs more, because the manifest also specifies the pod‚Äôs resource need of dedicated CPUs, KubeVirt will also add the node selector of <code class="language-plaintext highlighter-rouge">cpumanager=true</code> to guarantee that the pod is able to use the assigned CPUs alone. And finally, the scheduler also takes care of guaranteeing that the target node has sufficient free huge pages of the specified size (1Gi in our example) to satisfy the memory requested. With all these validations checked, the pod is successfully scheduled.</p>

<h2 id="key-takeaways">Key Takeaways</h2>

<p>Being able to run real-time workloads in KubeVirt with lower CPU latency opens new possibilities and expands the use cases where KubeVirt can assist in migrating legacy VMs into the cloud. Real-time workloads are extremely sensitive to the amount of layers between the bare metal and its runtime: the more layers in between, the higher the latency will be. The changes introduced in KubeVirt help reduce such waste and provide lower CPU latencies as the hardware is more efficiently tuned.</p>]]></content><author><name>Jordi Gil</name></author><category term="news" /><category term="kubevirt" /><category term="kubernetes" /><category term="virtual machine" /><category term="VM" /><category term="real-time" /><category term="NUMA" /><category term="CPUManager" /><summary type="html"><![CDATA[This blog post details the various enhancements made to improve the performance of real-time workloads in KubeVirt]]></summary></entry><entry><title type="html">KubeVirt v0.46.0</title><link href="https://kubevirt.io//2021/changelog-v0.46.0.html" rel="alternate" type="text/html" title="KubeVirt v0.46.0" /><published>2021-10-08T00:00:00+00:00</published><updated>2021-10-08T00:00:00+00:00</updated><id>https://kubevirt.io//2021/changelog-v0.46.0</id><content type="html" xml:base="https://kubevirt.io//2021/changelog-v0.46.0.html"><![CDATA[<h2 id="v0460">v0.46.0</h2>

<p>Released on: Fri Oct 8 21:12:33 2021 +0000</p>

<ul>
  <li>[PR #6425][awels] Hotplug disks are possible when iothreads are enabled.</li>
  <li>[PR #6297][acardace] mutate migration PDBs instead of creating an additional one for the duration of the migration.</li>
  <li>[PR #6464][awels] BugFix: Fixed hotplug race between kubelet and virt-handler when virt-launcher dies unexpectedly.</li>
  <li>[PR #6465][salanki] Fix corrupted DHCP Gateway Option from local DHCP server, leading to rejected IP configuration on Windows VMs.</li>
  <li>[PR #6458][vladikr] Tagged SR-IOV interfaces will now appear in the config drive metadata</li>
  <li>[PR #6446][brybacki] Access mode for virtctl image upload is now optional. This version of virtctl now requires CDI v1.34 or greater</li>
  <li>[PR #6391][zcahana] Cleanup obsolete permissions from virt-operator‚Äôs ClusterRole</li>
  <li>[PR #6419][rthallisey] Fix virt-controller panic caused by lots of deleted VMI events</li>
  <li>[PR #5972][kwiesmueller] Add a <code class="language-plaintext highlighter-rouge">ssh</code> command to <code class="language-plaintext highlighter-rouge">virtctl</code> that can be used to open SSH sessions to VMs/VMIs.</li>
  <li>[PR #6403][jrife] Removed go module pinning to an old version (v0.3.0) of github.com/go-kit/kit</li>
  <li>[PR #6367][brybacki] virtctl imageupload now uses DataVolume.spec.storage</li>
  <li>[PR #6198][iholder-redhat] Fire a Prometheus alert when a lot of REST failures are detected in virt-api</li>
  <li>[PR #6211][davidvossel] cluster-profiler pprof gathering tool and corresponding ‚ÄúClusterProfiler‚Äù feature gate</li>
  <li>[PR #6323][vladikr] switch live migration to use unix sockets</li>
  <li>[PR #6374][vladikr] Fix the default setting of CPU requests on vmipods</li>
  <li>[PR #6283][rthallisey] Record the time it takes to delete a VMI and expose it as a metric</li>
  <li>[PR #6251][rmohr] Better place vcpu threads on host cpus to form more efficient passthrough architectures</li>
  <li>[PR #6377][rmohr] Don‚Äôt fail on failed selinux relabel attempts if selinux is permissive</li>
  <li>[PR #6308][awels] BugFix: hotplug was broken when using it with a hostpath volume that was on a separate device.</li>
  <li>[PR #6186][davidvossel] Add resource and verb labels to rest_client_requests_total metric</li>
</ul>]]></content><author><name>kubeü§ñ</name></author><category term="releases" /><category term="release notes" /><category term="changelog" /><summary type="html"><![CDATA[This article provides information about KubeVirt release v0.46.0 changes]]></summary></entry><entry><title type="html">Import AWS AMIs as KubeVirt Golden Images</title><link href="https://kubevirt.io//2021/Importing-EC2-to-KubeVirt.html" rel="alternate" type="text/html" title="Import AWS AMIs as KubeVirt Golden Images" /><published>2021-09-21T00:00:00+00:00</published><updated>2021-09-21T00:00:00+00:00</updated><id>https://kubevirt.io//2021/Importing-EC2-to-KubeVirt</id><content type="html" xml:base="https://kubevirt.io//2021/Importing-EC2-to-KubeVirt.html"><![CDATA[<h2 id="breaking-out">Breaking Out</h2>

<p>There comes a point where an operations team has invested so heavily in a Iaas platform that they are effectively locked into that platform. For example, here‚Äôs one scenario outlining how this can happen. An operations team has created automation around building VM images and keeping images up-to-date. In AWS that automation likely involves starting an EC2 instance, injecting some application logic into that instance, sealing the instance‚Äôs boot source as an AMI, and finally copying that AMI around to all the AWS regions the team deploys in.</p>

<p>If the team was interested in evaluating KubeVirt as an alternative Iaas platform to AWS‚Äôs EC2, given the team‚Äôs existing tooling there‚Äôs not a clear path for doing this. It‚Äôs that scenario where the tooling in the <a href="https://github.com/davidvossel/kubevirt-cloud-import">kubevirt-cloud-import</a> project comes into play.</p>

<h2 id="kubevirt-cloud-import">Kubevirt Cloud Import</h2>

<p>The <a href="https://github.com/davidvossel/kubevirt-cloud-import">KubeVirt Cloud Import</a> project explores the practicality of transitioning VMs from various cloud providers into KubeVirt. As of writing this, automation for exporting AMIs from EC2 into KubeVirt works, and it‚Äôs really not all that complicated.</p>

<p>This blog post will explore the fundamentals of how AMIs are exported, and how the KubeVirt Cloud Import project leverages these techniques to build automation pipelines.</p>

<h2 id="nuts-and-bolts-of-importing-amis">Nuts and Bolts of Importing AMIs</h2>

<h3 id="official-aws-ami-export-support">Official AWS AMI Export Support</h3>

<p>AWS supports an <a href="https://docs.aws.amazon.com/vm-import/latest/userguide/vmexport_image.html">api</a> for exporting AMIs as a file to an s3 bucket. This support works quite well, however there‚Äôs a long list of <a href="https://docs.aws.amazon.com/vm-import/latest/userguide/vmexport_image.html#limits-image-export">limitations</a> that impact what AMIs are eligible for export. The most limiting of those items is the one that prevents any image built from an AMI on the marketplace from being eligible for the official export support.</p>

<h3 id="unofficial-aws-export-support">Unofficial AWS export Support</h3>

<p>Regardless of what AWS officially supports or not, there‚Äôs absolutely nothing preventing someone from exporting an AMI‚Äôs contents themselves. The technique just involves creating an EC2 instance, attaching an EBS volume (containing the AMI contents) as a block device, then streaming that block devices contents where ever you want.</p>

<p>Theoretically, the steps roughly look like this.</p>

<ul>
  <li>Convert AMI to a volume by finding the underlying AMI‚Äôs snapshot and converting it to an EBS volume.</li>
  <li>Create an EC2 instance with the EBS volume containing the AMI contents as a secondary data device.</li>
  <li>Within the EC2 guest, copy the EBS device‚Äôs contents as a disk img <code class="language-plaintext highlighter-rouge">dd if=/dev/xvda of=/tmp/disk/disk.img</code></li>
  <li>Then upload the disk image to an object store like s3. <code class="language-plaintext highlighter-rouge">aws s3 cp /tmp/disk/disk.img s3://my-b1-bucket/ upload: ../tmp/disk/disk.img to s3://my-b1-bucket/disk.img</code></li>
</ul>

<h3 id="basics-of-importing-data-into-kubevirt">Basics of Importing Data into KubeVirt</h3>

<p>Once a disk image is in s3, a KubeVirt companion project called the <a href="https://github.com/kubevirt/containerized-data-importer">Containerized Data Importer</a> (or CDI for short) can be used to import the disk from s3 into a PVC within the KubeVirt cluster. This import flow can be expressed as a CDI DataVolume custom resource.</p>

<p>Below is an example yaml for importing s3 contents into a PVC using a DataVolume</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">cdi.kubevirt.io/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">DataVolume</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">example-import-dv"</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">source</span><span class="pi">:</span>
      <span class="na">s3</span><span class="pi">:</span>
         <span class="na">url</span><span class="pi">:</span> <span class="s2">"</span><span class="s">https://s3.us-west-2.amazonaws.com/my-ami-exports/kubevirt-image-exports/export-ami-0dc4e69702f74df50.vmdk"</span>
         <span class="na">secretRef</span><span class="pi">:</span> <span class="s2">"</span><span class="s">my-s3-credentials"</span>
  <span class="na">pvc</span><span class="pi">:</span>
    <span class="na">accessModes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">ReadWriteOnce</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="na">requests</span><span class="pi">:</span>
        <span class="na">storage</span><span class="pi">:</span> <span class="s2">"</span><span class="s">6Gi"</span>
</code></pre></div></div>

<p>Once the AMI file content is stored in a PVC, CDI can be used further to clone that AMI‚Äôs PVC on a per VM basis. This effectively recreates the AMI to EC2 relationship that exists in AWS. You can find more information about CDI <a href="https://github.com/kubevirt/containerized-data-importer">here</a></p>

<h2 id="automating-ami-import">Automating AMI import</h2>

<p>Using the technique of exporting an AMI to an s3 bucket and importing the AMI from s3 into a KubeVirt cluster using CDI, the Kubevirt Cloud Import project provides the glue necessary for tying all of these pieces together in the form of the <code class="language-plaintext highlighter-rouge">import-ami</code> cli command and a Tekton task.</p>

<h2 id="automation-using-the-import-ami-cli-command">Automation using the import-ami CLI command</h2>

<p>The <code class="language-plaintext highlighter-rouge">import-ami</code> takes a set of arguments related to the AMI you wish to import into KubeVirt and the name of the PVC you‚Äôd like the AMI to be imported into. Upon execution, import-ami will call all the appropriate AWS and KubeVirt APIs to make this work. The result is a PVC with the AMI contents that is capable of being launched by a KubeVirt VM.</p>

<p>In the example below, A publicly shared <a href="https://alt.fedoraproject.org/cloud/">fedora34 AMI</a> is imported into the KubeVirt cluster as a PVC called fedora34-golden-image</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nb">export </span><span class="nv">S3_BUCKET</span><span class="o">=</span>my-bucket
<span class="nb">export </span><span class="nv">S3_SECRET</span><span class="o">=</span>s3-readonly-cred
<span class="nb">export </span><span class="nv">AWS_REGION</span><span class="o">=</span>us-west-2
<span class="nb">export </span><span class="nv">AMI_ID</span><span class="o">=</span>ami-00a4fdd3db8bb2851
<span class="nb">export </span><span class="nv">PVC_STORAGECLASS</span><span class="o">=</span>rook-ceph-block
<span class="nb">export </span><span class="nv">PVC_NAME</span><span class="o">=</span>fedora34-golden-image

import-ami <span class="nt">--s3-bucket</span> <span class="nv">$S3_BUCKET</span> <span class="nt">--region</span> <span class="nv">$AWS_REGION</span> <span class="nt">--ami-id</span> <span class="nv">$AMI_ID</span> <span class="nt">--pvc-storageclass</span> <span class="nv">$PVC_STORAGECLASS</span> <span class="nt">--s3-secret</span> <span class="nv">$S3_SECRET</span> <span class="nt">--pvc-name</span> <span class="nv">$PVC_NAME</span>

</code></pre></div></div>

<h2 id="automation-using-the-import-ami-tekton-task">Automation using the import-ami Tekton Task</h2>

<p>In addition to the <code class="language-plaintext highlighter-rouge">import-ami</code> cli command, the KubeVirt Cloud Import project also includes a <a href="https://github.com/davidvossel/kubevirt-cloud-import/blob/main/tasks/import-ami/manifests/import-ami.yaml">Tekton task</a> which wraps the cli command and allows integrating AMI import into a Tekton pipeline.</p>

<p>Using a Tekton pipeline, someone can combine the task of importing an AMI into KubeVirt with the task of starting a VM using that AMI. An example pipeline can be found <a href="https://raw.githubusercontent.com/davidvossel/kubevirt-cloud-import/main/examples/create-vm-from-ami-pipeline.yaml">here</a> which outlines how this is accomplished.</p>

<p>Below is a pipeline run that uses the example pipeline to import the publicly shared fedora34 AMI into a PVC, then starts a VM using that imported AMI.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nb">cat</span> <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> &gt; pipeline-run.yaml
apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
  name: my-vm-creation-pipeline
  namespace: default
spec:
  serviceAccountName: my-kubevirt-service-account
  pipelineRef:
    name: create-vm-pipeline 
  params:
    - name: vmName
      value: vm-fedora34
    - name: s3Bucket
      value: my-kubevirt-exports
    - name: s3ReadCredentialsSecret
      value: my-s3-read-only-credentials
    - name: awsRegion
      value: us-west-2
    - name: amiId 
      value: ami-00a4fdd3db8bb2851
    - name: pvcStorageClass 
      value: rook-ceph-block
    - name: pvcName
      value: fedora34
    - name: pvcNamespace
      value: default
    - name: pvcSize
      value: 6Gi
    - name: pvcAccessMode
      value: ReadWriteOnce
    - name: awsCredentialsSecret
      value: my-aws-credentials
</span><span class="no">EOF

</span>kubectl create <span class="nt">-f</span> pipeline-run.yaml
</code></pre></div></div>

<p>After posting the pipeline run, watch for the pipeline run to complete.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pipelinerun
selecting docker as container runtime
NAME                      SUCCEEDED   REASON      STARTTIME   COMPLETIONTIME
my-vm-creation-pipeline   True        Succeeded   11m         9m54s
</code></pre></div></div>

<p>Then observe that the resulting VM is online</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get vmi
selecting docker as container runtime
NAME          AGE   PHASE     IP               NODENAME   READY
vm-fedora34   11m   Running   10.244.196.175   node01     True
</code></pre></div></div>

<p>For more detailed and up-to-date information about how to automate AMI import using Tekton, view the KubeVirt Cloud Import <a href="https://github.com/davidvossel/kubevirt-cloud-import/blob/main/README.md">README.md</a></p>

<h2 id="key-takeaways">Key Takeaways</h2>

<p>The portability of workloads across different environments is becoming increasingly important and operations teams need to be vigilant about avoiding vendor lock in. For containers, Kubernetes is an attractive option because it provides a consistent API layer that can run across multiple cloud platforms. KubeVirt can provide that same level of consistency for VMs. As a community we need to invest further into automation tools that allow people to make the transition to KubeVirt.</p>]]></content><author><name>David Vossel</name></author><category term="news" /><category term="kubevirt" /><category term="kubernetes" /><category term="virtual machine" /><category term="VM" /><category term="AWS" /><category term="EC2" /><category term="AMI" /><summary type="html"><![CDATA[This blog post outlines the fundamentals for how to import VMs from AWS into KubeVirt]]></summary></entry><entry><title type="html">KubeVirt v0.45.0</title><link href="https://kubevirt.io//2021/changelog-v0.45.0.html" rel="alternate" type="text/html" title="KubeVirt v0.45.0" /><published>2021-09-08T00:00:00+00:00</published><updated>2021-09-08T00:00:00+00:00</updated><id>https://kubevirt.io//2021/changelog-v0.45.0</id><content type="html" xml:base="https://kubevirt.io//2021/changelog-v0.45.0.html"><![CDATA[<h2 id="v0450">v0.45.0</h2>

<p>Released on: Wed Sep 8 13:56:47 2021 +0000</p>

<ul>
  <li>[PR #6191][marceloamaral] Addition of perfscale-load-generator to perform stress tests to evaluate the control plane</li>
  <li>[PR #6248][VirrageS] Reduced logging in hot paths</li>
  <li>[PR #6079][weihanglo] Hotplug volume can be unplugged at anytime and reattached after a VM restart.</li>
  <li>[PR #6101][rmohr] Make k8s client rate limits configurable</li>
  <li>[PR #6204][sradco] This PR adds to each alert the runbook url that points to a runbook that provides additional details on each alert and how to mitigate it.</li>
  <li>[PR #5974][vladikr] a list of desired mdev types can now be provided in KubeVirt CR to kubevirt to configure these devices on relevant nodes</li>
  <li>[PR #6147][rmohr] Fix rbac permissions for freeze/unfreeze, addvolume/removevolume, guestosinfo, filesystemlist and userlist</li>
  <li>[PR #6161][ashleyschuett] Remove HostDevice validation on VMI creation</li>
  <li>[PR #6078][zcahana] Report ErrImagePull/ImagePullBackOff VM status when image pull errors occur</li>
  <li>[PR #6176][kwiesmueller] Fix goroutine leak in virt-handler, potentially causing issues with a high turnover of VMIs.</li>
  <li>[PR #6047][ShellyKa13] Add phases to the vm snapshot api, specifically a failure phase</li>
  <li>[PR #6138][ansijain] NA</li>
</ul>]]></content><author><name>kubeü§ñ</name></author><category term="releases" /><category term="release notes" /><category term="changelog" /><summary type="html"><![CDATA[This article provides information about KubeVirt release v0.45.0 changes]]></summary></entry><entry><title type="html">Running virtual machines in Istio service mesh</title><link href="https://kubevirt.io//2021/Virtual-machines-in-Istio-service-mesh.html" rel="alternate" type="text/html" title="Running virtual machines in Istio service mesh" /><published>2021-08-13T00:00:00+00:00</published><updated>2021-08-13T00:00:00+00:00</updated><id>https://kubevirt.io//2021/Virtual-machines-in-Istio-service-mesh</id><content type="html" xml:base="https://kubevirt.io//2021/Virtual-machines-in-Istio-service-mesh.html"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This blog post demonstrates running virtual machines in <a href="https://istio.io/">Istio</a> service mesh.</p>

<p>Istio service mesh allows to monitor, visualize, and manage traffic between pods and external services by
injecting a proxy container - a sidecar - which forwards inbound and outbound traffic of a pod/virtual machine.
This allows the sidecar to collect metadata about the proxied traffic and also actively interfere with it. For more in-depth information about the Istio proxy mechanism, see <a href="https://medium.com/open-5g-hypercore/episode-iii-meshville-7f0bb7ca0e3b">this blog post</a> published by Dough Smith et al.</p>

<p>The main features of Istio are traffic shifting (migrating traffic from an old to new version of a service), dynamic request routing, fault injection or traffic mirroring for testing/debugging purposes, and more.
Visit <a href="https://istio.io/latest/docs/tasks/">Istio documentation</a> to learn about all its features.
Istio featureset may be further extended by installing addons. Kiali, for example, is a UI dashboard that provides traffic information
of all microservices in a mesh, capable of composing communication graph between all microservices.</p>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
  <li>KubeVirt <code class="language-plaintext highlighter-rouge">v0.43.0</code></li>
  <li>CRI-O <code class="language-plaintext highlighter-rouge">v1.19.0</code></li>
</ul>

<h2 id="limitations">Limitations</h2>

<p>Istio is only supported with masquerade network binding and pod network over IPv4.</p>

<h2 id="demo">Demo</h2>

<p>This section covers deployment of a local cluster with Istio service mesh, KubeVirt installation and creation of an Istio-enabled virtual machine.
Finally, Kiali dashboard is used to examine both inbound and outbound traffic of the created virtual machine.</p>

<h3 id="run-kubernetes-cluster">Run Kubernetes cluster</h3>

<p>In this blog post, we are going to use <a href="https://github.com/kubevirt/kubevirtci">kubevirtci</a> as our Kubernetes ephemeral cluster provider.</p>

<p>Follow these steps to deploy a local cluster with pre-installed Istio service mesh:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/kubevirt/kubevirtci
<span class="nb">cd </span>kubevirtci
<span class="nb">export </span><span class="nv">KUBEVIRTCI_TAG</span><span class="o">=</span>2108222252-0007793
<span class="c"># Pin to version used in this blog post in case</span>
<span class="c"># k8s-1.21 provider version disappears in the future</span>
git checkout <span class="nv">$KUBEVIRTCI_TAG</span>
<span class="nb">export </span><span class="nv">KUBEVIRT_NUM_NODES</span><span class="o">=</span>2
<span class="nb">export </span><span class="nv">KUBEVIRT_PROVIDER</span><span class="o">=</span>k8s-1.21
<span class="nb">export </span><span class="nv">KUBEVIRT_DEPLOY_ISTIO</span><span class="o">=</span><span class="nb">true
export </span><span class="nv">KUBEVIRT_WITH_CNAO</span><span class="o">=</span><span class="nb">true
</span>make cluster-up
<span class="nb">export </span><span class="nv">KUBECONFIG</span><span class="o">=</span><span class="si">$(</span>./cluster-up/kubeconfig.sh<span class="si">)</span>
</code></pre></div></div>

<p>For details about Istio configuration, see Istio kubevirtci <a href="https://github.com/kubevirt/kubevirtci/blob/2108081530-91f55e3/cluster-provision/k8s/1.21/istio.sh">install script</a>.</p>

<h3 id="install-kubevirt">Install Kubevirt</h3>

<p>Following KubeVirt <a href="https://kubevirt.io/user-guide/operations/installation/#installing-kubevirt-on-kubernetes">user guide</a> to install released version <code class="language-plaintext highlighter-rouge">v0.43.0</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">RELEASE</span><span class="o">=</span>v0.43.0
kubectl apply <span class="nt">-f</span> <span class="s2">"https://github.com/kubevirt/kubevirt/releases/download/</span><span class="k">${</span><span class="nv">RELEASE</span><span class="k">}</span><span class="s2">/kubevirt-operator.yaml"</span>
kubectl apply <span class="nt">-f</span> <span class="s2">"https://github.com/kubevirt/kubevirt/releases/download/</span><span class="k">${</span><span class="nv">RELEASE</span><span class="k">}</span><span class="s2">/kubevirt-cr.yaml"</span>
kubectl <span class="nt">-n</span> kubevirt <span class="nb">wait </span>kv kubevirt <span class="nt">--timeout</span><span class="o">=</span>180s <span class="nt">--for</span> <span class="nv">condition</span><span class="o">=</span>Available
</code></pre></div></div>

<h3 id="install-istio-addons">Install Istio addons</h3>

<p>While the ephemeral kubevirtci installs core Istio components, addons like Kiali dashboard are not installed by default.
Download Istio manifests and client binary by running the following command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">ISTIO_VERSION</span><span class="o">=</span>1.10.0
curl <span class="nt">-L</span> https://istio.io/downloadIstio | sh -
</code></pre></div></div>

<p>and export path to the istioctl binary by following the output of the above command.</p>

<p>Finally, deploy Kiali, Jaeger and Prometheus addons:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create <span class="nt">-f</span> istio-<span class="k">${</span><span class="nv">ISTIO_VERSION</span><span class="k">}</span>/samples/addons/kiali.yaml
kubectl create <span class="nt">-f</span> istio-<span class="k">${</span><span class="nv">ISTIO_VERSION</span><span class="k">}</span>/samples/addons/jaeger.yaml
kubectl create <span class="nt">-f</span> istio-<span class="k">${</span><span class="nv">ISTIO_VERSION</span><span class="k">}</span>/samples/addons/prometheus.yaml
</code></pre></div></div>

<p><strong>Note:</strong> If there are errors when installing the addons, try running the command again. There may be timing issues which will be resolved when the command is run again.</p>

<h3 id="prepare-target-namespace">Prepare target namespace</h3>

<p>Before creating virtual machines, the target namespace needs to be configured for the Istio sidecar to be injected and working properly.
This involves adding a label and creating a <code class="language-plaintext highlighter-rouge">NetworkAttachmentDefinition</code> in the target namespace.</p>

<h4 id="istio-sidecar-injection">Istio sidecar injection</h4>

<p>Istio supports <a href="https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/">two ways of injecting</a> a sidecar to a pod - automatic and manual. For simplicity, we will only consider automatic sidecar injection in this demo, which is enabled by adding <code class="language-plaintext highlighter-rouge">istio-injection=enabled</code> label to target namespace:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl label namespace default istio-injection<span class="o">=</span>enabled
</code></pre></div></div>

<h4 id="network-attachment-definiton">Network attachment definiton</h4>

<p>When Multus is installed in k8s cluster, a <code class="language-plaintext highlighter-rouge">NetworkAttachmentDefinition</code> called <code class="language-plaintext highlighter-rouge">istio-cni</code> <strong>must</strong> be created in <strong>each</strong> namespace where Istio sidecar containers are to be used:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | kubectl create -f -
apiVersion: "k8s.cni.cncf.io/v1"
kind: NetworkAttachmentDefinition
metadata:
  name: istio-cni
</span><span class="no">EOF
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">NetworkAttachmentDefinition</code> spec is empty, as its only purpose is to trigger the <code class="language-plaintext highlighter-rouge">istio-cni</code> binary, which configures the in-pod traffic routing.</p>

<h3 id="topology">Topology</h3>

<p>To demonstrate monitoring and tracing capabilities, we will create two VMIs within Istio service mesh:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">istio-vmi</code> repeatedly requests external HTTP service kubevirt.io, and serves a simple HTTP server on port 8080,</li>
  <li><code class="language-plaintext highlighter-rouge">cirros-vmi</code> repeatedly request the HTTP service running on the <code class="language-plaintext highlighter-rouge">istio-vmi</code> VMI.</li>
</ul>

<p>With this setup, both inbound and outbound
traffic metrics can be observed in Kiali dashboard for <code class="language-plaintext highlighter-rouge">istio-vmi</code>.</p>

<h3 id="create-vmi-resources">Create VMI resources</h3>

<p>An Istio aware virtual machine <strong>must</strong> be annotated with <code class="language-plaintext highlighter-rouge">sidecar.istio.io/inject: "true"</code>, regardless of used Istio injection mechanism.
Without this annotation, traffic would not be properly routed through the istio proxy sidecar.
Additonally, Istio uses <code class="language-plaintext highlighter-rouge">app</code> label for adding contextual information to the collected telemetry.
Both, the annotation and label can be seen in the following virtual machine example:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | kubectl create -f -
apiVersion: kubevirt.io/v1
kind: VirtualMachineInstance
metadata:
  annotations:
    sidecar.istio.io/inject: "true"
  labels:
    app: istio-vmi
  name: istio-vmi
spec:
  domain:
    devices:
      interfaces:
        - name: default
          masquerade: {}
          ports:
            - port: 8080
      disks:
        - disk:
            bus: virtio
          name: containerdisk
        - disk:
            bus: virtio
          name: cloudinitdisk
    resources:
      requests:
        memory: 1024M
  networks:
    - name: default
      pod: {}
  readinessProbe:
    httpGet:
      port: 8080
    initialDelaySeconds: 120
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 3
  terminationGracePeriodSeconds: 0
  volumes:
    - name: containerdisk
      containerDisk:
        image: kubevirt/fedora-cloud-container-disk-demo:devel
    - cloudInitNoCloud:
        userData: |
          #cloud-config
          password: fedora
          chpasswd: { expire: False }
          runcmd:
          - dnf install -y screen nc
          - while true ; do sh -c "nc -lp 8080 -c  </span><span class="se">\"</span><span class="sh">echo -e 'HTTP/1.1 200 OK</span><span class="se">\n\n</span><span class="sh">Hello'</span><span class="se">\"</span><span class="sh"> " ; done &amp;
          - while true ; do curl kubevirt.io &gt;out 2&gt;/dev/null ; sleep 1 ; done &amp;
      name: cloudinitdisk
</span><span class="no">EOF
</span></code></pre></div></div>

<p>The cloud init section of the VMI runs two loops requesting <code class="language-plaintext highlighter-rouge">kubevirt.io</code> website every second to generate outbound traffic (from the VMI) and serving simple HTTP server on port <code class="language-plaintext highlighter-rouge">8080</code>, which will be used for monitoring of inbound traffic (to the VMI).</p>

<p>Let‚Äôs also create a service for the VMI that will be used to access the http server in <code class="language-plaintext highlighter-rouge">istio-vmi</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | kubectl create -f-
apiVersion: v1
kind: Service
metadata:
  name: istio-vmi-svc
spec:
  selector:
    app: istio-vmi
  ports:
  - port: 8080
    protocol: TCP
</span><span class="no">EOF
</span></code></pre></div></div>

<p>Finally, create the <code class="language-plaintext highlighter-rouge">cirros-vmi</code> VMI, for the purpose of generating inbound traffic to <code class="language-plaintext highlighter-rouge">istio-vmi</code> VMI:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | kubectl create -f -
apiVersion: kubevirt.io/v1
kind: VirtualMachineInstance
metadata:
  annotations:
    sidecar.istio.io/inject: "true"
  name: cirros-vmi
  labels:
    app: cirros-vmi
spec:
  domain:
    devices:
      interfaces:
        - name: default
          masquerade: {}
      disks:
        - disk:
            bus: virtio
          name: containerdisk
        - disk:
            bus: virtio
          name: cloudinitdisk
    resources:
      requests:
        memory: 128M
  networks:
    - name: default
      pod: {}
  terminationGracePeriodSeconds: 0
  volumes:
    - name: containerdisk
      containerDisk:
        image: kubevirt/cirros-container-disk-demo:devel
    - name: cloudinitdisk
      cloudInitNoCloud:
        userData: |
          #!/bin/sh
          while true ; do curl istio-vmi-svc.default.svc.cluster.local:8080 ; sleep 1 ; done
</span><span class="no">EOF
</span></code></pre></div></div>

<p>Wait for the <code class="language-plaintext highlighter-rouge">istio-vmi</code> to be ready:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl <span class="nb">wait</span> <span class="nt">--for</span><span class="o">=</span><span class="nv">condition</span><span class="o">=</span>ready <span class="nt">--timeout</span><span class="o">=</span>180s pod <span class="nt">-l</span> <span class="nv">app</span><span class="o">=</span>istio-vmi
</code></pre></div></div>

<p>After creating the VMIs, the corresponding virt-launcher pods should have 3 ready containers, as shown in the snippet below:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pods
NAME                             READY   STATUS    RESTARTS   AGE
virt-launcher-istio-vmi-XYZ      3/3     Running   0          4m13s
virt-launcher-cirros-vmi-XYZ     3/3     Running   0          2m21s
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Istioctl proxy-status</code> should report that the sidecar proxies running inside the virt-launcher pods have synced with Istio control plane:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>istioctl proxy-status
NAME                                          CDS        LDS        EDS        RDS          ISTIOD                      VERSION
virt-launcher-cirros-vmi-9f765.default        SYNCED     SYNCED     SYNCED     SYNCED       istiod-7d96484d6b-5d79g     1.10.0
virt-launcher-istio-vmi-99t8t.default         SYNCED     SYNCED     SYNCED     SYNCED       istiod-7d96484d6b-nk4cd     1.10.0
</code></pre></div></div>

<p><strong>Note:</strong> Displaying only relevant VMI entities.</p>

<h3 id="monitor-traffic-in-kiali-dashboard">Monitor traffic in Kiali dashboard</h3>

<p>With both VMIs up and running, we can open the Kiali dashboard and observe the traffic metrics.
Run the following command, to access Kiali dashboard:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>istioctl dashboard kiali
</code></pre></div></div>

<h4 id="topology-graph">Topology graph</h4>

<p>Let‚Äôs start by navigating to the topology graph by clicking the Graph menu item.</p>

<p><br /></p>
<div class="my-gallery" itemscope="" itemtype="http://schema.org/ImageGallery">
  <figure itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject">
    <a href="/assets/2021-08-13-Virtual-machines-in-Istio-service-mesh/topology-graph.png" itemprop="contentUrl" data-size="800x530">
      <img src="/assets/2021-08-13-Virtual-machines-in-Istio-service-mesh/topology-graph.png" itemprop="thumbnail" width="100%" alt="Topology graph" />
    </a>
    <figcaption itemprop="Topology graph of deployed VMIs showing the traffic flows"></figcaption>
  </figure>
</div>

<p>In the topology graph, we can observe the following traffic flows:</p>

<ul>
  <li>requests from <code class="language-plaintext highlighter-rouge">cirros-vmi</code> to <code class="language-plaintext highlighter-rouge">istio-vmi</code> via <code class="language-plaintext highlighter-rouge">istio-vmi-svc</code> service,</li>
  <li>requests from <code class="language-plaintext highlighter-rouge">istio-vmi</code> to <code class="language-plaintext highlighter-rouge">PasstroughCluster</code>. The <code class="language-plaintext highlighter-rouge">PastroughCluster</code> marks  destinations external to our service mesh.</li>
</ul>

<h4 id="workloads">Workloads</h4>

<p>Navigate to <code class="language-plaintext highlighter-rouge">istio-vmi</code> workload overview by clicking the <code class="language-plaintext highlighter-rouge">Workloads</code> menu item and selecting <code class="language-plaintext highlighter-rouge">istio-vmi</code> from the list.</p>

<p>The overview page presents partial topology graph with traffic related to <code class="language-plaintext highlighter-rouge">istio-vmi</code>. In our case, this graph is the same as the graph of our entire mesh.</p>

<p>Navigate to Inbound Metrics tab to see metrics charts of inbound traffic.</p>

<p><br /></p>
<div class="my-gallery" itemscope="" itemtype="http://schema.org/ImageGallery">
  <figure itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject">
    <a href="/assets/2021-08-13-Virtual-machines-in-Istio-service-mesh/istio-blog-vmi-istio-inbound-traffic.png" itemprop="contentUrl" data-size="800x530">
      <img src="/assets/2021-08-13-Virtual-machines-in-Istio-service-mesh/istio-blog-vmi-istio-inbound-traffic.png" itemprop="thumbnail" width="100%" alt="Inbound traffic metrics" />
    </a>
    <figcaption itemprop="Inbound traffic metrics for `istio-vmi`"></figcaption>
  </figure>
</div>

<p>In Request volume chart we can see that number of requests stabilizes at around <code class="language-plaintext highlighter-rouge">1 ops</code>, which matches our loop sending one reqest per second. Request throughput chart reveals that the requests consume around <code class="language-plaintext highlighter-rouge">4 kbit/s</code> of bandwidth.
Remaining two charts provide information about Request duration and size.</p>

<p>The same metrics are collected for outbound traffic as well, which can be seen in Outbound Metrics tab.</p>

<h2 id="cluster-teardown">Cluster teardown</h2>

<p>Run the following command to deprovision the ephemeral cluster:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make cluster-down
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>KubeVirt introduced <a href="https://kubevirt.io/user-guide/virtual_machines/istio_service_mesh/">support for Istio</a>, allowing virtual machines to be part of a service mesh.</p>

<p>This blog post covered running KubeVirt virtual machine in Istio service mesh using an ephemeral kubevirtci cluster. Kiali dashboard was used to observe inbound and outbound traffic of a virtual machine.</p>]]></content><author><name>Radim Hrazdil</name></author><category term="news" /><category term="kubevirt" /><category term="istio" /><category term="virtual machine" /><category term="VM" /><category term="service mesh" /><category term="mesh" /><summary type="html"><![CDATA[This blog post demonstrates running virtual machines in Istio service mesh.]]></summary></entry><entry><title type="html">KubeVirt v0.44.0</title><link href="https://kubevirt.io//2021/changelog-v0.44.0.html" rel="alternate" type="text/html" title="KubeVirt v0.44.0" /><published>2021-08-09T00:00:00+00:00</published><updated>2021-08-09T00:00:00+00:00</updated><id>https://kubevirt.io//2021/changelog-v0.44.0</id><content type="html" xml:base="https://kubevirt.io//2021/changelog-v0.44.0.html"><![CDATA[<h2 id="v0440">v0.44.0</h2>

<p>Released on: Mon Aug 9 14:20:14 2021 +0000</p>

<ul>
  <li>[PR #6058][acardace] Fix virt-launcher exit pod race condition</li>
  <li>[PR #6035][davidvossel] Addition of perfscale-audit tool for auditing performance of control plane during stress tests</li>
  <li>[PR #6145][acardace] virt-launcher: disable unencrypted TCP socket for libvirtd.</li>
  <li>[PR #6163][davidvossel] Handle qemu processes in defunc (zombie) state</li>
  <li>[PR #6105][ashleyschuett] Add VirtualMachineInstancesPerNode to KubeVirt CR under Spec.Configuration</li>
  <li>[PR #6104][zcahana] Report FailedUnschedulable VM status when scheduling errors occur</li>
  <li>[PR #5905][davidvossel] VM CrashLoop detection and Exponential Backoff</li>
  <li>[PR #6070][acardace] Initiate Live-Migration using a unix socket (exposed by virt-handler) instead of an additional TCP&lt;-&gt;Unix migration proxy started by virt-launcher</li>
  <li>[PR #5728][vasiliy-ul] Live migration of VMs with hotplug volumes is now enabled</li>
  <li>[PR #6109][rmohr] Fix virt-controller SCC: Reflect the need for NET_BIND_SERVICE in the virt-controller SCC.</li>
  <li>[PR #5942][ShellyKa13] Integrate guest agent to online VM snapshot</li>
  <li>[PR #6034][ashleyschuett] Go version updated to version 1.16.6</li>
  <li>[PR #6040][yuhaohaoyu] Improved debuggability by keeping the environment of a failed VMI alive.</li>
  <li>[PR #6068][dhiller] Add check that not all tests have been skipped</li>
  <li>[PR #6041][xpivarc] [Experimental] Virt-launcher can run as non-root user</li>
  <li>[PR #6062][iholder-redhat] replace dead ‚Äústress‚Äù binary with new, maintained, ‚Äústress-ng‚Äù binary</li>
  <li>[PR #6029][mhenriks] CDI to 1.36.0 with DataSource support</li>
  <li>[PR #4089][victortoso] Add support to USB Redirection with usbredir</li>
  <li>[PR #5946][vatsalparekh] Add guest-agent based ping probe</li>
  <li>[PR #6005][acardace] make containerDisk validation memory usage limit configurable</li>
  <li>[PR #5791][zcahana] Added a READY column to the tabular output of ‚Äúkubectl get vm/vmi‚Äù</li>
  <li>[PR #6006][awels] DataVolumes created by DataVolumeTemplates will follow the associated VMs priority class.</li>
  <li>[PR #5982][davidvossel] Reduce vmi Update collisions (http code 409) during startup</li>
  <li>[PR #5891][akalenyu] BugFix: Pending VMIs when creating concurrent bulk of VMs backed by WFFC DVs</li>
  <li>[PR #5925][rhrazdil] Fix issue with Windows VMs not being assigned IP address configured in network-attachment-definition IPAM.</li>
  <li>[PR #6007][rmohr] Fix: The bandwidth limitation on migrations is no longer ignored. Caution: The default bandwidth limitation of 64Mi is changed to ‚Äúunlimited‚Äù to not break existing installations.</li>
  <li>[PR #4944][kwiesmueller] Add <code class="language-plaintext highlighter-rouge">/portforward</code> subresource to <code class="language-plaintext highlighter-rouge">VirtualMachine</code> and <code class="language-plaintext highlighter-rouge">VirtualMachineInstance</code> that can tunnel TCP traffic through the API Server using a websocket stream.</li>
  <li>[PR #5402][alicefr] Integration of libguestfs-tools and added new command <code class="language-plaintext highlighter-rouge">guestfs</code> to virtctl</li>
  <li>[PR #5953][ashleyschuett] Allow Failed VMs to be stopped when using <code class="language-plaintext highlighter-rouge">--force --gracePeriod 0</code></li>
  <li>[PR #5876][mlsorensen] KubeVirt CR supports specifying a runtime class for virt-launcher pods via ‚ÄòlauncherRuntimeClass‚Äô.</li>
</ul>]]></content><author><name>kubeü§ñ</name></author><category term="releases" /><category term="release notes" /><category term="changelog" /><summary type="html"><![CDATA[This article provides information about KubeVirt release v0.44.0 changes]]></summary></entry><entry><title type="html">Kubernetes Authentication Options using KubeVirt Client Library</title><link href="https://kubevirt.io//2021/kubevirt-api-auth.html" rel="alternate" type="text/html" title="Kubernetes Authentication Options using KubeVirt Client Library" /><published>2021-07-16T00:00:00+00:00</published><updated>2021-07-16T00:00:00+00:00</updated><id>https://kubevirt.io//2021/kubevirt-api-auth</id><content type="html" xml:base="https://kubevirt.io//2021/kubevirt-api-auth.html"><![CDATA[<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#requirements">Requirements</a></li>
  <li><a href="#setup">Setup</a>
    <ul>
      <li><a href="#compiling-our-test-application">Compiling our test application</a></li>
    </ul>
  </li>
  <li><a href="#running-our-application-externally-leveraging-a-kubeconfig-file">Running our application externally leveraging a kubeconfig file</a>
    <ul>
      <li><a href="#using-the-default-kubeconfig">Using the default kubeconfig</a></li>
      <li><a href="#creating-a-kubeconfig-for-the-service-account">Creating a kubeconfig for the service account</a></li>
    </ul>
  </li>
  <li><a href="#running-in-a-kubernetes-cluster">Running in a Kubernetes Cluster</a></li>
  <li><a href="#extending-rbac-role-across-namespaces">Extending RBAC Role across Namespaces</a></li>
  <li><a href="#creating-custom-rbac-roles">Creating Custom RBAC Roles</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
  <li><a href="#references">References</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Most interaction with the KubeVirt service can be handled using the <em>virtctl</em> command, or raw yaml applied to your Kubernetes cluster. But what if you want to have more direct programmatic control over the instantiation and management of those virtual machines? The KubeVirt project supplies a Go client library for interacting with KubeVirt called <a href="https://github.com/kubevirt/client-go">client-go</a>. This library allows you to write your own applications that interact directly with the KubeVirt api quickly and easily.</p>

<p>In this post, we will use a simple application to demonstrate how the KubeVirt client library authenticates with your Kubernetes cluster both in and out of your cluster. This application is based on the example application in the ‚Äúclient-go‚Äù library with a few small modifications to it, to allow for running both locally and within in the cluster. This tutorial assumes you have some knowledge of Go, and is not meant to be a Go training doc.</p>

<h2 id="requirements">Requirements</h2>

<p>In order to compile and run the test application locally you will need to have the Go programming language installed on your machine. If you do not have the latest version of Go installed, follow the steps on the <a href="https://golang.org/dl/">Downloads</a> page of the Go  web site before proceeding with the rest of the steps in this blog. The steps listed here were tested with Go version 1.16.</p>

<p>You will need a Kubernetes cluster running with the KubeVirt operator installed. If you do not have a cluster available, the easiest way to do this is to follow the steps outlined in the <a href="https://kubevirt.io/quickstart_minikube/">Quick Start with Minikube</a> lab.</p>

<p>The example application we will be using to demonstrate the authentication methods lists out the VMI and VM instances in your cluster in the current namespace. If you do not have any running VMs in your cluster, be sure to create at least one new virtual machine instance in your cluster. For guidance in creating a quick test vm see the <a href="https://kubevirt.io/labs/kubernetes/lab1.html">Use KubeVirt</a> lab.</p>

<h2 id="setup">Setup</h2>

<h3 id="compiling-our-test-application">Compiling our test application</h3>

<p>Start by cloning the example application repo <a href="https://github.com/xphyr/kubevirt-apiauth">https://github.com/xphyr/kubevirt-apiauth</a> and compiling our test application:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/xphyr/kubevirt-apiauth.git
<span class="nb">cd </span>kubevirt-apiauth/listvms
go build
</code></pre></div></div>

<p>Once the program compiles, test to ensure that the application compiled correctly. If you have a working Kubernetes context, running this command may return some values. If you do not have a current context, you will get an error. This is OK, we will discuss authentication next.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./listvms
2021/06/23 16:51:28 cannot obtain KubeVirt vm list: Get <span class="s2">"http://localhost:8080/apis/kubevirt.io/v1alpha3/namespaces/default/virtualmachines"</span>: dial tcp 127.0.0.1:8080: connect: connection refused
</code></pre></div></div>

<p>As long as the program runs, you are all set to move onto the next step.</p>

<h2 id="running-our-application-externally-leveraging-a-kubeconfig-file">Running our application externally leveraging a kubeconfig file</h2>

<p>The default authentication file for Kubernetes is the <a href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig</a> file. We will not be going into details of this file, but you can click the link to goto the documentation on the kubeconfig file to learn more about it. All you need to know at this time is that when you use the <em>kubectl</em> command you are using a kubeconfig file for your authentication.</p>

<h3 id="using-the-default-kubeconfig">Using the default kubeconfig</h3>

<p>If you haven‚Äôt already done so, validate that you have a successful connection to your cluster with the ‚Äú<em>kubectl</em>‚Äù command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get nodes
NAME       STATUS   ROLES                  AGE     VERSION
minikube   Ready    control-plane,master   5d21h   v1.20.7
</code></pre></div></div>

<p>We now have a valid kubeconfig. On *nix OS such as Linux and OSX, this file is stored in your home directory at <code class="language-plaintext highlighter-rouge">~/.kube/config</code>. You should now be able to run our test application and get some results (assuming you have some running vms in your cluster).</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./listvms/listvms
Type                       Name       Namespace     Status
VirtualMachine             testvm     default       <span class="nb">false
</span>VirtualMachineInstance     testvm     default       Scheduled
</code></pre></div></div>

<p>This is great, but there is an issue. The authentication method we used is your primary Kubernetes authentication. It has roles and permissions to do many different things in your k8s cluster. Wouldn‚Äôt it be better if we could scope that authentication and ensure that your application had a dedicated account, with only the proper permissions to interact with just what your application will need. This is what Kubernetes <strong>Service Accounts</strong> are for.</p>

<p><a href="https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/">Service Accounts</a> are accounts for processes as opposed to users. By default they are scoped to a namespace, but you can give service accounts access to other namespaces through RBAC rules that we will discuss later. In this demo, we will be using the ‚Äú<em>default</em>‚Äù project/namespace, so the service account we create will be initially scoped only to this namespace.</p>

<p>Start by creating a new service account called ‚Äúmykubevirtrunner‚Äù using your default Kubernetes account:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create sa mykubevirtrunner
<span class="nv">$ </span>kubectl describe sa mykubevirtrunner
Name:                mykubevirtrunner
Namespace:           default
Labels:              &lt;none&gt;
Annotations:         &lt;none&gt;
Image pull secrets:  &lt;none&gt;
Mountable secrets:   mykubevirtrunner-token-pd2mq
Tokens:              mykubevirtrunner-token-pd2mq
Events:              &lt;none&gt;
</code></pre></div></div>

<p>In the describe output you can see that a token and a mountable secret have been created. Let‚Äôs take a look at the contents of the secret:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl describe secret mykubevirtrunner-token-pd2mq
Name:         mykubevirtrunner-token-pd2mq
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  kubernetes.io/service-account.name: mykubevirtrunner
              kubernetes.io/service-account.uid: f401493b-658a-489d-bcce-0ccce39160a0

Type:  kubernetes.io/service-account-token

Data
<span class="o">====</span>
namespace:  7 bytes
token:      eyJhbGciOiJS...
ca.crt:     1111 bytes

</code></pre></div></div>

<p>The data listed for the ‚Äútoken‚Äù key is the information we will use in the next step, your output will be much longer, it has been truncated for this document. Ensure when copying the value that you get the entire token value.</p>

<h3 id="creating-a-kubeconfig-for-the-service-account">Creating a kubeconfig for the service account</h3>

<p>We will create a new kubeconfig file that leverages the service account and token we just created. The easiest way to do this is to create an empty kubeconfig file, and use the ‚Äú<em>kubectl</em>‚Äù command to log in with the new token. Open a NEW terminal window. This will be the window we use for the service account. In this new terminal window start by setting the KUBECONFIG environment variable to point to a file in our local directory, and then using the ‚Äú<em>kubectl</em>‚Äù command to generate a new kubeconfig file:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">KUBECONFIG</span><span class="o">=</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>/sa-kubeconfig
kubectl config set-cluster minikube <span class="nt">--server</span><span class="o">=</span>https://&lt;update IP address&gt;:8443 <span class="nt">--insecure-skip-tls-verify</span>
kubectl config set-credentials mykubevirtrunner <span class="nt">--token</span><span class="o">=</span>&lt;<span class="nb">paste </span>token from last step here&gt;
kubectl config set-context minikube <span class="nt">--cluster</span><span class="o">=</span>minikube <span class="nt">--namespace</span><span class="o">=</span>default <span class="nt">--user</span><span class="o">=</span>mykubevirtrunner
kubectl config use-context minikube
</code></pre></div></div>

<p>We can test that the new kubeconfig file is working by running a kubectl command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pods
Error from server <span class="o">(</span>Forbidden<span class="o">)</span>: pods is forbidden: User <span class="s2">"system:serviceaccount:default:mykubevirtrunner"</span> cannot list resource <span class="s2">"pods"</span> <span class="k">in </span>API group <span class="s2">""</span> <span class="k">in </span>the namespace <span class="s2">"default"</span>
</code></pre></div></div>

<p>Note that the ‚ÄúUser‚Äù is now listed as ‚Äú<em>system:serviceaccount:default:mykubevirtrunner</em>‚Äù so we know we are using our new service account. Now try running our test program and note that it is using the service account as well:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>listvms/listvms
2021/07/07 14:53:23 cannot obtain KubeVirt vm list: virtualmachines.kubevirt.io is forbidden: User <span class="s2">"system:serviceaccount:default:mykubevirtrunner"</span> cannot list resource <span class="s2">"virtualmachines"</span> <span class="k">in </span>API group <span class="s2">"kubevirt.io"</span> <span class="k">in </span>the namespace <span class="s2">"default"</span>
</code></pre></div></div>

<p>You can see we are now using our service account in our application, but that service account doesn‚Äôt have the right permissions‚Ä¶ We now need to assign a role to our service account to give it the proper API access. We will start simple and give the service account the <strong>kubevirt.io:view</strong> role, which will allow the service account to see the KubeVirt objects within the ‚Äú<em>default</em>‚Äù namespace:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create clusterrolebinding kubevirt-viewer <span class="nt">--clusterrole</span><span class="o">=</span>kubevirt.io:view <span class="nt">--serviceaccount</span><span class="o">=</span>default:mykubevirtrunner
clusterrolebinding.rbac.authorization.k8s.io/kubevirt-viewer created
</code></pre></div></div>

<p>Now run the <em>listvms</em> command again:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./listvms/listvms
Type                       Name                    Namespace     Status
VirtualMachineInstance     vm-fedora-ephemeral     myvms         Running
</code></pre></div></div>

<p>Success! Our application is now using the service account that we created for authentication to the cluster. The service account can be extended by adding additional default roles to the account, or by creating custom roles that limit the scope of the service account to only the exact actions you want to take. When you install KubeVirt you get a set of default roles including ‚ÄúView‚Äù, ‚ÄúEdit‚Äù and ‚ÄúAdmin‚Äù. Additional details about these roles are available here: <a href="https://kubevirt.io/user-guide/operations/authorization/">KubeVirt Default RBAC Cluster Roles</a></p>

<h2 id="running-in-a-kubernetes-cluster">Running in a Kubernetes Cluster</h2>

<p>So all of this is great if you want to run the application outside of your cluster ‚Ä¶ but what if you want your application to run INSIDE you cluster. You could create a kubeconfig file, and add it to your namespace as a secret and then mount that secret as a volume inside your pod, but there is an easier way that continues to leverage the service account that we created. By default Kubernetes creates a few environment variables for every pod that indicate that the container is running within Kubernetes, and it makes a Kubernetes authentication token for the service account that the container is running as available at /var/run/secrets/kubernetes.io/serviceaccount/token. The client-go KubeVirt library can detect that it is running inside a Kubernetes hosted container and will transparently use the authentication token provided with no additional configuration needed.</p>

<p>A container image with the listvms binary is available at <strong>quay.io/markd/listvms</strong>. We can start a copy of this container using the deployment yaml file located in the ‚Äòlistvms/listvms_deployment.yaml‚Äô file.</p>

<p>Switch back to your original terminal window that is using your primary kubeconfig file, and using the ‚Äú<em>kubectl</em>‚Äù command deploy one instance of the test pod, and then check the logs of the pod:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create <span class="nt">-f</span> listvms/listvms_deployment.yaml
<span class="nv">$ </span>kubectl get pods
NAME                                      READY   STATUS    RESTARTS   AGE
listvms-7b8f865c8d-2zqqn                  1/1     Running   0          7m30s
virt-launcher-vm-fedora-ephemeral-4ljg4   2/2     Running   0          24h
<span class="nv">$ </span>kubectl logs listvms-7b8f865c8d-2zqqn
2021/07/07 19:06:42 cannot obtain KubeVirt vm list: virtualmachines.kubevirt.io is forbidden: User <span class="s2">"system:serviceaccount:default:default"</span> cannot list resource <span class="s2">"virtualmachines"</span> <span class="k">in </span>API group <span class="s2">"kubevirt.io"</span> <span class="k">in </span>the namespace <span class="s2">"default"</span>
</code></pre></div></div>

<blockquote>
  <p><strong>NOTE:</strong> Be sure to deploy this demo application in a namespace that contains at least one running VM or VMI.</p>
</blockquote>

<p>The application is unable to run the operation, because it is running as the default service account in the ‚Äú<em>default</em>‚Äù namespace. If you remember previously we created a service account in this namespace called ‚Äúmykubevirtrunner‚Äù. We need only update the deployment to use this service account and we should see some success. Use the ‚Äúkubectl edit deployment/listvms‚Äù command to update the container spec to include the ‚ÄúserviceAccount: mykubevirtrunner‚Äù line as show below:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">listvms</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">quay.io/markd/listvms</span>
      <span class="na">serviceAccount</span><span class="pi">:</span> <span class="s">mykubevirtrunner</span>
      <span class="na">securityContext</span><span class="pi">:</span> <span class="pi">{}</span>
      <span class="na">schedulerName</span><span class="pi">:</span> <span class="s">default-scheduler</span>
</code></pre></div></div>

<p>This change will trigger Kubernetes to redeploy your pod, using the new serviceAccount. We should now see some output from our program:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get pods
NAME                                      READY   STATUS    RESTARTS   AGE
listvms-7b8f865c8d-2qzzn                  1/1     Running   0          7m30s
virt-launcher-vm-fedora-ephemeral-4ljg4   2/2     Running   0          24h
<span class="nv">$ </span>kubectl logs listvms-7b8f865c8d-2qzzn
Type                       Name                    Namespace     Status
VirtualMachineInstance     vm-fedora-ephemeral     myvms         Running
awaiting signal
</code></pre></div></div>

<h2 id="extending-rbac-role-across-namespaces">Extending RBAC Role across Namespaces</h2>

<p>As currently configured, the mykubevirtrunner service account can only ‚Äúview‚Äù KubeVirt resources within its own namespace. If we want to extend that ability to other namespaces, we can add the view role for other namespaces to the mykubevirtrunner serviceAccount.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create namespace myvms
&lt;launch an addition vm here&gt;
kubectl create clusterrolebinding kubevirt-viewer <span class="nt">--clusterrole</span><span class="o">=</span>kubevirt.io:view <span class="nt">--serviceaccount</span><span class="o">=</span>default:mykubevirtrunner <span class="nt">-n</span> myvms
</code></pre></div></div>

<p>We can test that the ServiceAccount has been updated to also have permissions to view in the ‚Äúmyvms‚Äù namespace by running our listvms command one more time, this time passing in the optional flag <em>‚Äìnamespaces</em>. Switch to your terminal window that is using the service account kubeconfig file and run the following command:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>listvms/listvms <span class="nt">--namespaces</span> myvms
additional namespaces to check are:  myvms
Checking the following namespaces:  <span class="o">[</span>default myvms]
Type                       Name       Namespace     Status
VirtualMachine             testvm     default       <span class="nb">false
</span>VirtualMachineInstance     testvm     default       Scheduled
VirtualMachine             testvm     myvms         <span class="nb">false</span>
</code></pre></div></div>

<p>You can see that now, the ServiceAccount can view the vm and vmi that are in both the default namespace as well as the <em>myvms</em> namespace.</p>

<h2 id="creating-custom-rbac-roles">Creating Custom RBAC Roles</h2>

<p>In this demo we used RBAC roles created as part of the KubeVirt install. You can also create custom RBAC roles for KubeVirt. Documentation on how this can be done is available in the KubeVirt documentation <a href="https://kubevirt.io/user-guide/operations/authorization/#creating-custom-rbac-roles">Creating Custom RBAC Roles</a></p>

<h2 id="conclusion">Conclusion</h2>

<p>It is possible to control and manage your KubeVirt machines with the use of Kubernetes service accounts and the ‚Äúclient-go‚Äù library. When using service accounts, you want to ensure that the account has the minimum role or permissions to do it‚Äôs job to ensure the security of your cluster. The ‚Äúclient-go‚Äù library gives you options on how you authenticate with your Kubernetes cluster, allowing you to deploy your application both in and out of your Kubernetes cluster.</p>

<h2 id="references">References</h2>

<p><a href="https://github.com/kubevirt/client-go">KubeVirt Client Go</a></p>

<p><a href="https://kubevirt.io/2018/KubeVirt-API-Access-Control.html">KubeVirt API Access Control</a></p>

<p><a href="https://kubevirt.io/user-guide/operations/authorization/">KubeVirt Default RBAC Cluster Roles</a></p>]]></content><author><name>Mark DeNeve</name></author><category term="news" /><category term="kubevirt" /><category term="go" /><category term="api" /><category term="authentication" /><summary type="html"><![CDATA[This blog post discusses authentication methods that can be used with the KubeVirt client-go library.]]></summary></entry></feed>